# Chapter 6 - Literal Expressions

This is the first chapter in Part 2 of the book titled Expressions and Filters. Expressions provide a frictionless access to the core of Angular's scope system. They allow us to concisely access and manipular data on scopes and run computations on it.

In Angular, the value of expressions is to bind data and behavior to HTML markup in directives like ngClass or ngClick, and we use them binding data to the contents and attributes of DOM elements with the interpolation syntax `{{ }}`.

In this part, we will also be talking about filters, which are functions we run by adding the unix style pipe character `|` to modify the return value. 

## A Whole New Language

So are the expressions just JavaScript code? Actually, they can be better thought of as a whole new language that is modeled after JavaScript. In other words, expressions are almost pure JavaScript, but it actually extends JavaScript, such as the `|` operation which isn't in native JS.

This expression language is parsed by JavaScript. What we need to do now is write a parser that takes in a string and returns a JavaScript function that can be executed. This brings us into the world of parsers, lexers, and abstract syntax trees. Let's get to it.

## Literal Expressions

We are going to start off my parsing literal expressions. Literal expressions are simple data expressions that represent themselves, such as numbers, strings, arrays, unlike identifiers, and function calls. These are the simplest kind of expressions to parse.

Our parser file is going to consist of four obejcts that do all of the work of turning expressions into functions:
 * A lexer - takes the original expression and returns an array of tokens 
 * An AST builder - takes the array of tokens and builds up an AST
 * An AST compiler - takes the AST and compiles it into JavaScript functions
 * A Parser - the interface to and facilitator of the above three objects


For example, lets take a provided expressions of `a+b`. First, the lexer parses that into its individual tokens:

```
[ 
  {text: 'a', identifier: true},
  {text: '+'},
  {text: 'b', identifier: true}
]
```

With that array, we construct our AST with the AST builder. That will end up looking like this:

```
{
    type: AST.BinaryExpression,
    operator: '+',
    left: {
        type: AST.Identifer,
        name: 'a'
    },
    right: {
        type: AST.Identifer,
        name: 'b'
    }
}
```

Lastly, the AST compiler turns this into an executable function.

```
function(scope) {
    return scope.a + scope.b;
}
```

## Parsing Integers

The first expression we are going to be parsing is a simple integer. The expected result is that our parser will return a function that, when executed, returns the number in the expression.

This brings us to the expression of how to implement our lexer. What is a token? A token is an object that gives the AST Builder all of the information it needs to construct an AST. For integers, we need just two things for our numeric literal - the text and the numeric value.

```
{
    text: '42',
    value: 42
}
```

Our lexer is going to iterate over every character in the expression to form the collection of tokens. For numbers, once we have detected a number, we can read the next character until we no longer have a number and concatenate the characters together. The number is then added as a token.

Once we have a token, we can create an AST. The AST is a nested JS object that represents in an expression in a tree-like form. Each node will have a type attribute that describes the syntactic structure the node represents. Our numeric literals will be of the type `AST.Literal` and every root node has a type of `AST.Program`. The root node has an attribute called body that holds the contents of the expression.

```
{ 
  type: AST.Program,
  body: {
    type: AST.Literal,
    value: 42
  }
} 
```

Lastly, the job of the AST Compiler is to walk over the tree generated by the AST builder and build up the JavaScript source code that represents our expression. In the main compile function, we'll introduce a state attribute into which we will collect information while walking the tree. Once we initialize the state, we'll start recursively walking through the tree. How we handle each part will vary based on the token type.

So how do we actually turn our AST into functions? We can use JavaScript's Function constructor to crate the function. The constructor takes some JavaScript source and code and compiles it into a function. This is essentially a form of `eval` and is not recommended for use, but we have to use it here.
